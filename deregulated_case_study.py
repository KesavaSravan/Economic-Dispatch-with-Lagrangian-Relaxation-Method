# -*- coding: utf-8 -*-
"""Deregulated_case_study.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aN8H7Am8hYJdKoqnv91cQ4QRgnqjy8_X
"""

# Economic Dispatch Problem with Lagrangian Relaxation Method
# H Kesava Sravan - CB.EN.U4ELC20023
# B Ram Narayan - CB.EN.U4ELC20055
# K Pranathi - CB.EN.U4EEE20054
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import minimize

data=pd.read_csv('Economic_Dispatch_PROBLEM.csv')
data

a = data['a']
b = data['b']
c = data['c']
min_capacity = data['Min_Capacity']
max_capacity = data['Max_Capacity']
# Power demand values
power_demand = [700, 800, 900, 1000, 1100]

# Function to calculate the cost for a given power output
def calculate_cost(P, a, b, c):
    return a * np.square(P) + b * P + c

# Objective function for optimization (to minimize the cost)
def objective_function(P, a, b, c, lambda_val, power_demand):
    return sum(calculate_cost(P, a, b, c)) + lambda_val * (sum(P) - power_demand)

# Constraint function for the total power demand
def total_power_constraint(P, power_demand):
    return sum(P) - power_demand

# Function to perform Economic Load Dispatch using Lagrangian Relaxation
def economic_load_dispatch(a, b, c, min_capacity, max_capacity, power_demand):
    num_units = len(a)

    results = []
    total_costs = []  # List to store total costs for each demand level
    for demand in power_demand:
        initial_guess = np.ones(num_units) * (demand / num_units)  # Initial guess for power output
        # Initialize lambda_val
        lambda_val = 0
        while True:
            # Optimization using constrained minimization
            optimization_result = minimize(
                lambda P: objective_function(P, a, b, c, lambda_val, demand),
                initial_guess,
                constraints={'type': 'eq', 'fun': total_power_constraint, 'args': (demand,)},
                bounds=[(min_capacity[i], max_capacity[i]) for i in range(num_units)]
            )

            # Extract optimized power outputs
            optimized_power = optimization_result.x

            # Calculate total fuel cost for the current demand
            total_fuel_cost = sum(calculate_cost(optimized_power, a, b, c))

            # Update lambda_val
            lambda_val += sum(optimized_power) - demand

            # Check convergence
            if abs(sum(optimized_power) - demand) < 1e-5:
                break

        # Calculate total cost for the current demand
        total_cost = sum(calculate_cost(optimized_power, a, b, c))
        total_costs.append(total_cost)

        # Append results to the list
        results.append({
            'Powerdemand': demand,
            'P1': optimized_power[0],
            'P2': optimized_power[1],
            'P3': optimized_power[2],
            'P4': optimized_power[3],
            'P5': optimized_power[4],
            'P6': optimized_power[5],
            'Lambda': lambda_val,
            'TotalFuelCost': total_fuel_cost
        })

    # Create a DataFrame for the results
    result_df = pd.DataFrame(results)

    # Plotting the variation of cost with power demand
    plt.figure(figsize=(8, 6))
    plt.plot(power_demand, total_costs, marker='o', linestyle='-')
    plt.title('Variation of Cost with Power Demand')
    plt.xlabel('Power Demand')
    plt.ylabel('Total Cost')
    plt.grid(True)
    plt.show()

    return result_df

# Perform Economic Load Dispatch and plot the curve
result_table = economic_load_dispatch(a, b, c, min_capacity, max_capacity, power_demand)
print(result_table)